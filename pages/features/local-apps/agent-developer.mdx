---
title: "Agent Developer Guide"
description: "How to build AI Agents for Local Apps"
---

import { Callout } from 'nextra/components'

# Agent Developer Guide

This guide is for developers building AI Agents that process data from Local Apps.

## How Agents Receive Tasks

When a Local App triggers an agent (via SDK or Supabase event), RealTimeX creates an **External Task**.

1. **Agent triggered**: The agent receives the `raw_data` from the event.
2. **Locking (Important)**: In a distributed system, the agent should first **claim** the task to prevent multiple agents from processing the same data.
3. **Processing**: The agent runs its logic (e.g., summarizing text, analyzing data).
4. **Reporting**: The agent reports the final status (completed/failed) back to RealTimeX.

## Responding to Tasks

Agents should interact with the RealTimeX **Proxy Webhook**. This webhook automatically handles status updates in the Main App and syncs changes back to the Local App/Supabase.

### Webhook API Reference

**Endpoint**: `POST /api/external-tasks/:uuid/webhook`

#### 1. Claim Task
Before starting work, call the claim action. This will attempt to acquire a lock (via Supabase RPC or Local App API).

**Request:**
```json
{
  "action": "claim",
  "machine_id": "agent-unique-id",
  "user_email": "user@example.com"
}
```

**Response (Success):**
```json
{
  "success": true,
  "status": "claimed",
  "locked_by": "agent-unique-id"
}
```

---

#### 2. Start Processing
Optional: Mark the task as `processing`.

**Request:**
```json
{
  "action": "start",
  "machine_id": "agent-unique-id"
}
```

---

#### 3. Complete Task
Report the final result.

**Request:**
```json
{
  "action": "complete",
  "machine_id": "agent-unique-id",
  "data": {
    "summary": "The analysis is complete...",
    "result": { "key": "value" }
  }
}
```

---

#### 4. Fail Task
Report an error if processing fails.

**Request:**
```json
{
  "action": "fail",
  "machine_id": "agent-unique-id",
  "data": {
    "error": "Failed to connect to external service"
  }
}
```

## Context Variables

When an agent is triggered by an External Task, it receives several context variables:

| Variable | Description |
|----------|-------------|
| `task_uuid` | Unique identifier for the task |
| `webhook_url` | Full URL to the proxy webhook |
| `raw_data` | The original event data from the database |
| `table_name` | The name of the source table |

## Best Practices

### 1. Atomic Locking
Always use the `claim` action before processing. The RealTimeX proxy handles the low-level locking logic for you, whether you're in **Compatible** or **Custom** mode.

### 2. Meaningful Status
If an agent fails, return a clear error message in the `data.error` field. This helps users debug issues directly from the **Local App Execution Logs**.

### 3. Handle Large Data
Avoid passing massive blobs in `raw_data`. If you're processing files, pass a Supabase Storage URL or a signed URL instead.

## Local Testing

To test your agent locally:
1. Use the **SDK** to trigger a "Manual" event.
2. Verify the task appears in the **Calendar**.
3. Use the **"Trigger Agent"** button in the Calendar to run your agent manually.
4. Monitor the **Execution Logs** to verify the webhook calls and status updates.
